---
title: '机器学习总结'
date: 2017-03-02
permalink: /posts/2012/08/blog-post-1/
mathjax: true
tags:
  - '知识积累'
  - '机器学习'
---

!["Algorithm World"](\images\20170302-Algorithm World.jpg)

>机器学习（Machine Learning，ML）是一门多领域交叉学科，涉及概率统计、非线性优化、信息论、人工智能、计算复杂性和控制论等多门学科。目的是用计算机模拟或实现人类的学习行为，随着经验积累自动提高性能。

# 1 机器学习算法
## 1.1 问题分类

&emsp;&emsp;根据问题本身的特征来分类，机器学习问题可分为监督学习、无监督学习、半监督学习和强化学习。

  * <b>监督学习（Supervised Learning）</b>的特点是训练数据是有标签的，即对于每个输入都有相对应的输出，算法的目的是训练出能反应输入与输出之间的映射关系的模型。对于输出值是离散的（有限个数），称之为分类问题（Classification Problem）；对于输出值是连续的，则称之为<b>回归问题（Regression Problem）</b>。
  * <b>无监督学习（Unsupervised Learning）</b>的训练数据是没有标签的，即没有确定的输出值，就需要根据数据提取特征，这类问题的算法包括关联规则和聚类算法等。
<!-- more -->
  * <b>半监督学习（Semi-supervised Learning）</b>是介于监督学习和非监督学习之间，即数据一部分有标签，一部分没有标签，算法一半是需要考虑利用少量的标注样本和大量的非标注样本来完成训练、回归或分类。常用算法包括自训练（Self-training）、直推学习（ Transductive Learning）、生成式模型（Generative Model）。
  
&emsp;&emsp;除此了上述的三类之外，还有<b>强化学习（Reinforcement Learning）</b>这一新兴的分类。强化学习是从环境状态到行为映射的学习，通过反复与环境交互来改进策略，以使系统行为从环境中获得的累积奖赏值最大。强化学习现主要应用于智能控制及分析预测等领域。强化学习可以动态地调整参数，与监督学习的区别在于产生的动作和获得的奖赏没有明确的函数形式表示，只能采用试探的方式进行，如果某一动作获得的奖赏为正，则以后产生这一动作的趋势会增加，反之则会减弱。

## 1.2 算法分类

&emsp;&emsp;现在机器学习的算法较多， 按照功能分类太大体可分为<b>回归（Regression）</b>、<b>分类（Classification）</b>、<b>聚类（Cluster）</b>、<b>维度约减（Dimensionality Reduction）</b>四个类别。其中回归和分类问题虽然在定义上有区别（连续和离散），但在本质上是一样的，算法是可以通用的，因此把二者涉及的算法归在一起。具体划分情况为：

  （1）    回归和分类    
  
  * <b>线性回归（Linear Regression）</b>：拟合自变量和因变量线性关系的统计分析方法，常用最小二乘法来求解参数。
  * <b>多项式回归（Polynomial Regression）</b>：自变量次数大于1，但具体的次数选择往往要依靠经验，次数太高容易过拟合。
  * <b>朴素贝叶斯（Native Bayes，NB）</b>：由贝叶斯公式得到的分类器，通过计算后验概率来分类。
  * <b>逻辑斯蒂回归（Logistic Regression）</b>：在线性回归的基础上应用逻辑函数，函数值位于0到1之间，二值分类以0.5为界限。
  * <b>支持向量机（Support Vector Machine，SVM）</b>：在较长一段时间被誉为二值分类问题最佳的模型。通过核函数映射，将低维线性不可分的数据集映射到高维，使其线性可分，并使分类界面间隔最大。算法求解过程用到了二次规划、拉格朗日乘子法、KKT条件、对偶问题、SMO算法等。SVM算法善于处理小样本问题。
  * <b>K近邻（K-Nearest Neighbors，KNN）</b>：基于实例的算法，通过距离公式来寻找相似样本来做回归预测，依赖于样本数据的质和量，算法很成熟但计算量较大，因此后来又提出了KD树的方法。
  * <b>决策树（Decision Trees，DT）</b>：直观运用概率的图解方法，按特征来生成决策树，使目标期望达到最大，实际使用过程特征选择方式和决策树的修剪是关键。决策树算法包括迭代二叉树（Iterative Dichotomiser 3，ID3）、C4.5和CART（Classification And Regression Tree）等衍生算法。
  * <b>神经网络（Neural Network，NN）</b>：模仿人类大脑的神经突触结构，从而完成信息的传递处理，是目前最流行的机器学习算法之一。
    
&emsp;&emsp;神经网络按照隐层数的多少可分为浅层学习和深层学习，浅层学习包括感知器（Perceptron）、多层感知器（Multi-Layer Perceptron，MLP）、反馈神经网络（Back Propagation Neural Network，BP-NN）、径向基函数神经网络（Radial Basis Function Neural Network，RBF-NN）、极限学习机（Extreme Learning Machine，ELM）等，深层学习包括深度置信网络（Deep Belief Nets，DBN）、循环神经网络（Recurrent Neural Network，RNN）、卷积神经网络（Convolutional Neural Network，CNN）等等。

   在实际使用过程中，往往还使用<b>模型融合算法(Ensemble Algorithms)</b>，这类的算法包括：  
   
  * <b>Bagging（Bootstrap aggregation）</b>：每次从样本集随机采样来训练弱分类器，重复多次，最后用投票的方式（分类）或求均值（回归）得到最后结果。
  * <b>随机森林（Random Forest）</b>：随机构造很多的CART（由树组成森林），模型关键参数是树个数目和树节点输入特征的个数（总特征树的子集，随机选取），通过综合决策树的结果得到分类结果。
  * <b>自适应提升方法（Adaptive Boosting）</b>：采用赋权的方式，先设置初始权重，然后每个弱分类器训练完根据效果改变权重，训练失败的样本增加权重，最后综合多个弱分类器的结果得到强分类器。

  （2）    聚类
  
  &emsp;&emsp;在部分学者的观点来看，数据挖掘的核心就是聚类，聚类问题是典型的无监督学习，按一定的规则将类似的样本进行组合的方式。大量数据可先通过聚类划分不同的类别，然后再进行其他机器学习的处理。
   常用的聚类算法包括：
   
  * <b>K均值聚类（K-Means Cluster）</b>：随机选择K个样本作为类别中心，根据离中心的聚类确定各个样本的归属，然后通过迭代的方式不断更新类别中心，直至不变。K值大小的选取很关键。
  * <b>层次聚类法（Hierarchical Cluster）</b>：由起初的所有样本各自归为一类，根据样本间的聚类合并类并重新计算样本中心，迭代进行直至中心间距离大于限定阈值或达到限定的类别个数。每次迭代要计算两两间距，计算量较大。
  * <b>期望最大算法（Expectation Maximization ，EM）</b>：迭代分成E步和M步，用于含有隐变量（Hidden Variable）的概率模型参数的极大后验概率估计。典型的应用是高斯混合模型（Gaussian Mixture Model，GMM），随机选择初始中心，按所属各个分布的概率大小进行分类。
    
   （3）    维度约减
  
  &emsp;&emsp;维度约减，即降维，是特征提前的过程，对于特征数特别多的数据集往往需要提取主要的特征，剔除次要特征，将数据集由高维映射到低维。
   主要的算法包括：
   
  * <b>主成分分析（Principal Component Analysis，PCA）</b>：数学基础是特征值分析，根据协方差矩阵求特征值和特征向量，按特征值大小依次选择特征向量构成特征矩阵。主成分分析得先做数据中心化。
  * <b>奇异值分解（Singular Value Decomposition，SVD）</b>：将原始矩阵X分解成三个矩阵相乘，前后是正交非方阵，中间的是XTX的特征值平方根构成的对角阵，然后也是按特征值大小来选取特征。SVD其实算是PCA的一种处理方法。    * <b>偏最小二乘法（partial least squares method，PLS）</b>：偏最小二乘是多种方法的结合，包括多元线性回归、典型相关分析和主成份分析。在主成份分析中所选取的变量都是独立的，在特征之间的相关性较大的时候容易漏掉关键特征，而偏最小二乘可以避免这个问题。
    
## 1.3 学习策略
  * （1）批量学习（Batch Learning）
    * （a）样本全部同时进入模型；
    * （b）梯度下降的方法容易陷入局部最优；
    * （c）学习并行性，速度快，但耗费存储量大。
  * （2）在线学习（Online Learning）
    * （a）样本按顺序进入模型，不断修正模型参数；
    * （b）随机性强，不容易陷入局部最优；
    * （c）学习串行性，需要依次迭代速度慢，但耗费存储量小。
    
# 2 模型选择

## 2.1 基础知识

&emsp;&emsp;系统识别主要是要解决两个问题: 
  *  （1）建模描述系统输入与输出的函数映射关系；
  *  （2）确定模型参数。
  
&emsp;&emsp;建模过程考虑的几个重要因素：
  * <b>泛化能力</b>：对未知空间的预测能力，衡量模型优劣的主要指标；
  * <b>解释能力</b>：建模是用数学的方法来解释现实问题，目的是通过模型找寻实际问题的最佳解决措施。
  * <b>维数灾难</b>：模型可能涉及到很多的参数是无法通过样本来准确估计的，或者由于过多的参数而导致模型的泛化能力变差。
  * <b>计算能力</b>：通常，随着模型的复杂度增加，所带来的计算复杂度也会倍增，甚至是指数性增加。
  * <b>输入选择</b>：对于模型输入的变量并不是越多越好，如果输入中含有的无效成分太多，反而会影响最终输出结果。因此，要合理选择模型输入。
  * <b>鲁棒性和抗扰性</b>：传统的线性系统常常是建立在带有高斯噪音的线性时不变过程。而实际动态的过程往往是复杂、非线性、非平稳、随机且部分未知的，因此保证模型的鲁棒性和抗干扰性是一大难题。
  * <b>在线更新</b>：对于持续输入样本的模型，不仅要实现参数实时更新，也要实现模型结构的自适应调整。

## 2.2 “过拟合”

&emsp;&emsp;在过去，机器学习的目标往往是关注经验风险最小化（Empirical Risk Minimization，ERM），即以训练样本误差最小化来衡量模型的好坏，从而无限增加模型的复杂度。然而随着模型复杂度增加，模型的泛化能力反而会下降，即出现了“过拟合”现象，而提高泛化能力要综合考虑模型的偏差（Bias）和方差（Variance）。以均方误差来（Mean Square error，MSE）来衡量模型的泛化误差的话，对于$Y=f(x)+e$，$e$是$N(0,\sigma_e)$分布的噪声干扰（白噪声），则模型泛化误差为：

![“泛化误差”](/images/20170302-1.jpg)  
  
&emsp;&emsp;如图所示，随着模型的复杂度增加，虽然偏差会不断减小，但方差先减小后增大，模型的泛化误差也是先减小后增大，因此需要在“欠拟合”和“过拟合”之间寻找合适的模型复杂度。衡量模型的复杂度通常有AIC准则（Akalike Information Criterion）、BIC准则（Bayesian Information Criterion）等方法。

![“过拟合”](/images/20170302-2.jpg) 

  *  （1）赤池信息量准则（Akalike Information Criterion，AIC准则）

  $$AIC=-2ln L+2d$$<br>
  
&emsp;&emsp;其中，L是样本训练误差的极大似然值，假设误差服从正态分布，则误差越小，L越大，d是模型参数个数。AIC越小，则模型越好，即在保证参数个数少的情况下达到误差最小。
  
  *  （2）贝叶斯信息量准则（Bayesian Information Criterion，BIC准则）
  
  $$ BIC=-2ln L+2d\ln n $$<br>
  
&emsp;&emsp;这是基于贝叶斯角度考虑的推论，但实际上其与AIC准则表达式类似，也是越小越好。

## 2.3 正则化

  &emsp;&emsp;在满足一定训练精度要求的情况下，倾向于选择、稀疏的模型结构来避免“过拟合”，这就是<b>奥卡姆剃刀定律（Occam's Razor）：“如无必要，勿增实体” （Entities should not be multiplied unnecessarily）</b>，即用简单有效的方法完成要求做的事。
在机器学习中，控制模型复杂度典型方法是采用正则化。正则化的思想是<b>结构风险最小化（Structural Risk Minimization，SRM）</b>策略，在经验风险上加一个正则化项（Regularizer）或罚项（Penalty term）。从贝叶斯估计的角度来看，正则化项对应于模型的先验概率，模型越复杂则先验概率概率越大，结构风险也就越大。
  &emsp;&emsp;正则化方法有L0阶、L1阶和L2阶范数三种，其中L0阶范数的求解是NP难问题，较少采用；L1阶范数又称<b>LASSO（least absolute shrinkage and selection operator）</b>，作用是特征选择；L2阶范数又称<b>岭回归（ridge regression）</b>，作用是权值衰减。
  &emsp;&emsp;在实际应用中，岭回归是保证回归矩阵权值的平方和尽可能小，无法产生稀疏化的回归矩阵和起到选择重要参数的目的，但在样本数较多的情况下，岭回归的精度高于LASSO。介于L1阶和L2阶范数之间还有<b>elastic net</b>方法，此时代价函数为：<br> 
 
$$L(\lambda _1,\lambda _2,\beta) = |y - X\beta {|^2} + {\lambda _1}|\beta {|_1} + {\lambda _2}|\beta {|^2}$$ <br>
  
&emsp;&emsp;这里，式子右边的第二、三项分别对应L1阶和L2阶范数。如果用形象化方式表达三者的关系，如图2所示。LASSO的特征选择方式的几何解释可以参考修正的<b>最小角回归（Least Angle Regression）</b>算法。由最残差相关系数最大的方向出发，随着前进步长增大，最优方向与残差的相关系数变小，直至找到次优参数方向，参数依次进入模型

![“正则化”](/images/20170302-3.jpg)  


# 2 优化算法
## 2.1 优化问题分类
  
  * <b>一维搜索</b>：求目标函数在直线上的极小点，称为一维搜索，或称为线搜索。一维搜索可归结为单变量函数的极小化问题。一维搜索包括试探法和函数逼近法。试探法：针对单峰函数，包括0.618法（黄金分割法）和Fibonacci法等；函数逼近法（插值法）：牛顿法、割线法和抛物线法等。
  * <b>无约束问题优化法</b>：目标问题没有约束条件，包括最速下降法、牛顿法、共轭梯度法、拟牛顿法等求解方法。
  * <b>约束问题优化法</b>：目标问题有约束条件，包括可行方向法（Zoutendijk法）、惩罚函数法、乘子法、序列二次规划法等求解方法。
  * <b>整数规划</b>：目标函数和约束函数是线性函数，还要求决策变量取整数值，包括分支定界法、割平面法等求解方法
  * <b>动态规划</b>：解决多阶段决策过程最优化的一种数学方法，主要用于以时间或地域划分阶段的动态过程的最优化。动态规划的经典问题是最短路问题和生成贮存问题。求解方法包括逆推法和顺推法。
  * <b>最优性原理</b>：作为整个过程的最优策略具有这样的性质：无论初始状态和初始决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。
  * <b>多目标规划</b>：目标函数含有多个子目标，互相之间可能是相互矛盾的，在这多个子目标之间进行协调和权衡，使各个子目标尽可能地达到理想值。对于多个目标可以采用加权等方式整合成单目标，也可以通过重要性排序等方式依次确定各个目标的最优，常用解法是遗传算法（GA）。
  
## 2.2 典型优化算法

  * （1）遗传算法（Genetic Algorithm，GA）: 遗传算法是人工智能算法的重要分支，原理是模拟生物进化论和遗传学机理的生物进化过程的计算模型，包含了“适者生存”、“优胜劣汰”等规则。遗传算法包含遗传、变异和选择三个流程。个体编码常用无符号的二进制整数来表示。具体步骤包括：构造一定规模的初始种群，计算适应度决定遗传的概率，遗传运算（常用轮盘赌法），交叉运算（按概率发生片段交换）、变异运算（较小概率随机发生突变，防止陷入局部最优）。

  * （2）模拟退火算法（Simulated Annealing Algorithm，SA或SAA）: 模拟退火算法源于固体退火原理，基于蒙特卡洛（Monte Calro）法迭代求解测量的一种随机寻优的算法。在某一初温下，伴随温度不断下降，结合概率突跳特性在解空间中随机寻找目标函数的全局最优解。模拟退火包括加温、等温和冷却（退火）过程。设定初始值，进行蒙特卡洛模拟新状态，优化状态完全接受，也以一定概率接受劣化状态（防止局部最优），直到得到满足要求的解。这种方法本质还是随机求解法，计算量大，时间长。

  * （3）蚁群算法（Ant Colny Optimization，ACO）: 蚁群算法是一种用来在图中寻找优化路径的几率型算法，源于蚂蚁在寻找食物过程发现最优路径的行为。典型的应用是用于解决旅行商问题（Traveling salesman problem, TSP）。算法的一般步骤： 
  
     * （a）初始化参数：开始时每条边的信息素量都相等；
     * （b）将各只蚂蚁随机放置各个顶点；
     * （c）依次选取蚂蚁周游所有顶点，计算转移概率（由每条边的信息素和启发因子决定，启发因子为路阻的倒数），以轮盘赌法决定下一个顶点，计算蚂蚁留在各边的信息素，更新信息素表。
     * （d）计算各边的信息素增量，记录本次迭代的路径，更新当前最优路径，清空信息素表。
     * （e）迭代运行，终止条件：最大迭代次数或停滞现象。
    
  * （4）粒子群算法（Particle Swarm Optimization，PSO）: 粒子群算法源于对鸟群捕食行为的研究，求解过程是从随机解出发，通过迭代寻找最优解，通过适应度评价解的品质。粒子群算法的一般过程：

    * （a）随机初始化一组微粒（问题可行解），包括随机位置和速度；
    * （b）评价每个微粒的适应度；
    * （c）根据个体极值和群体极值来更新当前位置。
    * （d）重复（b）和（c），记录下每个微粒每次迭代的位置和适应度，直至找到最优解。

